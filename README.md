# Демьяненко Виктор Николаевич БПИ217
## Домашнее задание по ОС #4
## Вариант 29

# UPDATE:
TCP -> UDP

## Цель и задачи: 
Изучить работу с транспортным протоколом TCP. Научиться разбивать задачу  на части, для последующего их выполнения серверами и клиентами.

## Условие задачи:

Первая военная задача. Темной–темной ночью прапорщики Иванов, Петров и Нечепорук занимаются хищением военного имущества со склада родной военной части. Будучи умными людьми и
отличниками боевой и строевой подготовки, прапорщики ввели разделение труда. Иванов выносит имущество со склада и передает его
в руки Петрову, который грузит его в грузовик. Нечепорук стоит на
шухере и заодно подсчитывает рыночную стоимость добычи поле
погрузки в грузовик очередной партии похищенного. Требуется
создать приложение, моделирующее деятельность прапорщиков. Время выполнения каждого действия прапорщиков–
процессов задавать случайным образом.

## Выполненное условие:

- 4 балла ✓
- 5 балла ✓
- 6 балла ✓
- 7 балла ✓
- 8 балла ✓

## Сценарий задачи:

Для решения данной задачи клиент-серверного взаимодействия между прапорщиками Ивановым, Петровым и Нечепоруком, мы можем использовать схему "один сервер - множество клиентов". Сервер будет отвечать за координацию действий и хранение общих данных, а каждый клиент (прапорщик) будет выполнять свою задачу в отдельном процессе. Также в этот раз изменил я изменил имена прапорщиков на "Вор".

## Схема решения 

1. Сервер запускается и создает необходимые для работы ресурсы, такие как разделяемая память и семафоры.
2. Клиенты (прапорщики) запускаются и подключаются к серверу.
3. Каждый клиент случайным образом определяет время выполнения своих действий, например, время выноса имущества со склада и загрузки его в грузовик.
4. Клиенты отправляют запросы серверу для получения доступа к общим ресурсам (например, семафорам) перед выполнением своих действий.
5. Сервер обрабатывает запросы клиентов и контролирует доступ к общим ресурсам, чтобы обеспечить взаимоисключение и согласованность операций.
6. Клиенты выполняют свои действия (выносят имущество со склада, загружают его в грузовик) и отправляют обновленные данные серверуx`.
7. Сервер получает обновленные данные от клиентов и может выполнять дополнительную обработку, например, подсчет рыночной стоимости добычи.
8. Процесс повторяется до достижения заданного условия завершения (например, заданное количество циклов выполнения действий).

Каждый процесс клиента (прапорщика) будет выполнять следующие шаги:

1. Подключение к серверу.
2. Генерация случайного времени выполнения действий.
3. Цикл действий, включающий:
- Ожидание разрешения доступа к общим ресурсам, отправка запроса серверу.
- Выполнение действий (вынос имущества, загрузка в грузовик).
- Обновление данных и отправка их серверу.
- Ожидание разрешения доступа к общим ресурсам после выполнения действий.
4. Отключение от сервера и завершение процесса клиента.

## Завершение программы и удаление ресурсов

- Программа будет завершаться, когда все процессы прапорщиков успешно выполнят свои действия или при прерывании с клавиатуры по соответствующему сигналу (например, Ctrl+C). При завершении программы будет предусмотрено корректное удаление разделяемой памяти и семафоров.
- Разделяемая память и семафоры будут корректно удалены при завершении программы или при обработке сигнала прерывания с клавиатуры. Это будет выполнено с использованием функций удаления разделяемой памяти и семафоров.


## Код сервера на языке С:

```C
// Код сервера

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <time.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>

// Ключи для разделяемой памяти и семафора
#define SHM_KEY 1234
#define SEM_KEY 5678
#define PORT 8888

// Структура для хранения похищенного имущества
typedef struct
{
    int items;
    int value;
} StolenGoods;

// Функция для ожидания освобождения семафора
void sem_wait(int sem_id)
{
    struct sembuf sem_op = {0, -1, 0};
    semop(sem_id, &sem_op, 1);
}

// Функция для освобождения семафора
void sem_post(int sem_id)
{
    struct sembuf sem_op = {0, 1, 0};
    semop(sem_id, &sem_op, 1);
}

int main()
{
    // Создание ключей для разделяемой памяти и семафора
    int shm_id = shmget(SHM_KEY, sizeof(StolenGoods), IPC_CREAT | 0666);
    if (shm_id == -1)
    {
        perror("Ошибка создания разделяемой памяти");
        exit(EXIT_FAILURE);
    }
    int sem_id = semget(SEM_KEY, 1, IPC_CREAT | 0666);
    if (sem_id == -1)
    {
        perror("Ошибка создания/получения семафора");
        exit(EXIT_FAILURE);
    }

    // Инициализация генератора случайных чисел
    srand(time(NULL));

    // Инициализация разделяемой памяти
    StolenGoods *stolen_goods = (StolenGoods *)shmat(shm_id, NULL, 0);
    if (stolen_goods == (void *)-1)
    {
        perror("Ошибка отображения разделяемой памяти");
        exit(EXIT_FAILURE);
    }

    stolen_goods->items = 0;
    stolen_goods->value = 0;

    // Инициализация семафора
    semctl(sem_id, 0, SETVAL, 1);

    // Создание сокета UDP
    int sockfd;
    struct sockaddr_in serverAddr, clientAddr;
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        perror("Ошибка создания сокета");
        exit(EXIT_FAILURE);
    }

    memset(&serverAddr, 0, sizeof(serverAddr));
    memset(&clientAddr, 0, sizeof(clientAddr));

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    // Привязка сокета к адресу сервера
    if (bind(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
    {
        perror("Ошибка привязки сокета");
        exit(EXIT_FAILURE);
    }

    printf("Сервер: ожидание запроса от клиента...\n");

    // Главный цикл сервера
    while (1)
    {
        // Ожидание запроса от клиента
        int len, n;
        len = sizeof(clientAddr);
        n = recvfrom(sockfd, NULL, 0, MSG_WAITALL, (struct sockaddr *)&clientAddr, &len);
        if (n < 0)
        {
            perror("Ошибка приема данных");
            exit(EXIT_FAILURE);
        }

        // Запрос доступа к общим ресурсам
        sem_wait(sem_id);

        // Обработка запроса
        if (stolen_goods->items == 0)
        {
            printf("Сервер: на складе тихо...\n");
        }

        // Освобождение доступа к общим ресурсам
        sem_post(sem_id);

        if (stolen_goods->items != 0)
        {
            printf("Сервер: у нас украли %d предметов со склада...\n", stolen_goods->items);
        }
        // Проверка условия завершения
        if (stolen_goods->items >= rand() % 41 + 10)
        {
            break; // Завершение сервера
        }

        // Задержка перед следующей итерацией
        sleep(1);
    }

    printf("Тревога! У нас украли %d товаров со склада с общей стоимостью в %d$!!!\n", stolen_goods->items, stolen_goods->value);
    // Отключение от разделяемой памяти
    shmdt(stolen_goods);

    // Удаление разделяемой памяти и семафора
    shmctl(shm_id, IPC_RMID, NULL);
    semctl(sem_id, 0, IPC_RMID);

    return 0;
}


```


## Результаты программы:

```
Дочерний процесс с PID 188 похитил товар. Всего похищено: 1
Дочерний процесс с PID 189 похитил товар. Всего похищено: 2
Дочерний процесс с PID 190 похитил товар. Всего похищено: 3
Дочерний процесс с PID 188 похитил товар. Всего похищено: 4
Дочерний процесс с PID 189 похитил товар. Всего похищено: 5
Дочерний процесс с PID 190 похитил товар. Всего похищено: 6
Дочерний процесс с PID 188 похитил товар. Всего похищено: 7
Дочерний процесс с PID 189 похитил товар. Всего похищено: 8
Дочерний процесс с PID 190 похитил товар. Всего похищено: 9
Дочерний процесс с PID 188 похитил товар. Всего похищено: 10
Дочерний процесс с PID 189 похитил товар. Всего похищено: 11
Дочерний процесс с PID 190 похитил товар. Всего похищено: 12
Дочерний процесс с PID 188 похитил товар. Всего похищено: 13
Дочерний процесс с PID 189 похитил товар. Всего похищено: 14
Дочерний процесс с PID 190 похитил товар. Всего похищено: 15
Дочерний процесс с PID 188 похитил товар. Всего похищено: 16
Дочерний процесс с PID 189 похитил товар. Всего похищено: 17
Дочерний процесс с PID 190 похитил товар. Всего похищено: 18
Дочерний процесс с PID 188 похитил товар. Всего похищено: 19
Дочерний процесс с PID 189 похитил товар. Всего похищено: 20
Дочерний процесс с PID 190 похитил товар. Всего похищено: 21
Дочерний процесс с PID 188 похитил товар. Всего похищено: 22
Дочерний процесс с PID 189 похитил товар. Всего похищено: 23
Дочерний процесс с PID 190 похитил товар. Всего похищено: 24
Дочерний процесс с PID 188 похитил товар. Всего похищено: 25
Дочерний процесс с PID 189 похитил товар. Всего похищено: 26
Дочерний процесс с PID 190 похитил товар. Всего похищено: 27
Дочерний процесс с PID 188 похитил товар. Всего похищено: 28
Дочерний процесс с PID 189 похитил товар. Всего похищено: 29
Дочерний процесс с PID 190 похитил товар. Всего похищено: 30
Дочерний процесс с PID 188 завершил работу. Всего похищено: 30, Общая стоимость: 7712
Дочерний процесс с PID 189 завершил работу. Всего похищено: 30, Общая стоимость: 8376
Дочерний процесс с PID 190 завершил работу. Всего похищено: 30, Общая стоимость: 8844
```


## Код на 8 баллов (prog_8.c)

``` C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <pthread.h>

#define PORT 8080

typedef struct
{
    int items;
    int value;
} StolenGoods;

typedef struct
{
    int socket;
    int isObserver;
} ClientInfo;

StolenGoods stolenGoods; // Объявление структуры StolenGoods
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // Инициализация мьютекса
int observerSocket = -1; // Сокет наблюдателя
pthread_mutex_t observerMutex = PTHREAD_MUTEX_INITIALIZER; // Мьютекс для доступа к сокету наблюдателя

void *clientHandler(void *arg)
{
    ClientInfo client = *(ClientInfo *)arg;
    char buffer[1024];

    // Отправка разрешения доступа к общим ресурсам
    sendto(client.socket, "Access granted", strlen("Access granted"), 0, NULL, 0);

    // Если клиент - наблюдатель, сохраняем его сокет
    if (client.isObserver)
    {
        pthread_mutex_lock(&observerMutex);
        observerSocket = client.socket;
        printf("Сервер: наблюдатель подключен\n");

        // Отправляем начальную стоимость склада
        char valueStr[20];
        snprintf(valueStr, sizeof(valueStr), "%d", stolenGoods.value);
        sendto(observerSocket, valueStr, strlen(valueStr), 0, NULL, 0);
        pthread_mutex_unlock(&observerMutex);
    }

    // Главный цикл обработки клиента
    while (1)
    {
        // Получение данных от клиента
        memset(buffer, 0, sizeof(buffer));
        socklen_t clientAddrLen;
        int bytesReceived = recvfrom(client.socket, buffer, sizeof(buffer), 0, (struct sockaddr *)&clientAddr, &clientAddrLen);
        if (bytesReceived <= 0)
        {
            // Проблема при получении данных или соединение закрыто
            break;
        }

        // Проверка условия завершения
        if (stolenGoods.items <= 0 || stolenGoods.value <= 0)
        {
            printf("Сервер: все предметы похищены\n");
            break;
        }

        // Обновление структуры с похищенным имуществом
        int price = rand() % 41 + 10;
        pthread_mutex_lock(&mutex);
        stolenGoods.items--;
        stolenGoods.value -= price;

        printf("Сервер: со склада похитили товар стоимостью в %d$.\n", price);

        // Преобразование стоимости в строку
        char valueStr[20];
        snprintf(valueStr, sizeof(valueStr), "%d", stolenGoods.value);

        // Отправка стоимости клиенту
        sendto(client.socket, valueStr, strlen(valueStr), 0, (struct sockaddr *)&clientAddr, clientAddrLen);

        // Отправка стоимости наблюдателю
        if (client.isObserver)
        {
            pthread_mutex_lock(&observerMutex);
            if (observerSocket != -1)
            {
                sendto(observerSocket, valueStr, strlen(valueStr), 0, NULL, 0);
            }
            pthread_mutex_unlock(&observerMutex);
        }

        pthread_mutex_unlock(&mutex);

        // Задержка перед следующей итерацией
        sleep(1);
    }

    // Закрытие сокета клиента
    close(client.socket);
    pthread_exit(NULL);
}

int main()
{
    int serverSocket;
    struct sockaddr_in serverAddr, clientAddr;
    socklen_t addrLen = sizeof(clientAddr);
    char buffer[1024];
    pthread_t threadId;

    // Создание сокета
    if ((serverSocket = socket(AF_INET, SOCK_DGRAM, 0)) == 0)
    {
        perror("Ошибка создания сокета");
        exit(EXIT_FAILURE);
    }

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(PORT);

    // Привязка сокета к указанному порту
    if (bind(serverSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
    {
        perror("Ошибка привязки сокета");
        exit(EXIT_FAILURE);
    }

    printf("Сервер: ожидание подключений...\n");

    // Инициализация структуры с похищенным имуществом
    stolenGoods.items = 100;  // Начальное количество предметов
    stolenGoods.value = 1000; // Начальная стоимость

    // Главный цикл сервера
    while (1)
    {
        // Принятие нового подключения от клиента
        if (recvfrom(serverSocket, buffer, sizeof(buffer), 0, (struct sockaddr *)&clientAddr, &addrLen) < 0)
        {
            perror("Ошибка при принятии подключения");
            exit(EXIT_FAILURE);
        }

        printf("Сервер: новое подключение принято\n");

        // Создание потока для обработки клиента
        ClientInfo client;
        client.socket = serverSocket;

        // Проверка, является ли клиент наблюдателем
        if (strstr(buffer, "2") != NULL)
        {
            client.isObserver = 1;
        }
        else
        {
            client.isObserver = 0;
        }

        if (pthread_create(&threadId, NULL, clientHandler, (void *)&client) != 0)
        {
            perror("Ошибка при создании потока");
            exit(EXIT_FAILURE);
        }

        // Проверка условия завершения
        if (stolenGoods.items <= 0 || stolenGoods.value <= 0)
        {
            close(serverSocket);
            break;
        }
    }

    // Закрытие сокета сервера
    close(serverSocket);

    return 0;
}


```

Вывод программы:

```
Дочерний процесс 2776 запущен
Дочерний процесс 2776 украл 1 предметов на сумму 32
Дочерний процесс 2777 запущен
Дочерний процесс 2777 украл 2 предметов на сумму 64
Дочерний процесс 2778 запущен
Дочерний процесс 2778 украл 3 предметов на сумму 96
Дочерний процесс 2776 украл 4 предметов на сумму 128
Дочерний процесс 2777 украл 5 предметов на сумму 160
Дочерний процесс 2778 украл 6 предметов на сумму 192
Дочерний процесс 2776 украл 7 предметов на сумму 246
Дочерний процесс 2777 украл 8 предметов на сумму 300
Дочерний процесс 2778 украл 9 предметов на сумму 354
Дочерний процесс 2776 украл 10 предметов на сумму 366
Дочерний процесс 2777 украл 11 предметов на сумму 378
Дочерний процесс 2778 украл 12 предметов на сумму 390
Дочерний процесс 2776 украл 13 предметов на сумму 442
Дочерний процесс 2777 украл 14 предметов на сумму 494
Дочерний процесс 2778 украл 15 предметов на сумму 546
Дочерний процесс 2776 завершен. Общая стоимость: 182
Дочерний процесс 2777 завершен. Общая стоимость: 182
Дочерний процесс 2778 завершен. Общая стоимость: 182

```
